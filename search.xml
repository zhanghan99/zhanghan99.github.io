<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2020/07/09/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/07/09/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><pre><code>1.默认方法：    默认方法就是一个在接口里面有了一个实现的方法2.方法引用：    方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。    与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。3.Lambda表达式：    Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。4.Stream API：    新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。5.Date Time API：    加强对日期与时间的处理5.Optional类：    Optional类已经成为Java 8 类库的一部分，用来解决空指针异常。</code></pre><!-- move --><h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><h3 id="原始接口"><a href="#原始接口" class="headerlink" title="原始接口"></a>原始接口</h3><p><strong>接口定义</strong></p><p>&nbsp;&nbsp;&nbsp;<br>接口的作用:定义一套标准、规范，一个公共的规则，所以接口中的之声明方法签名，不提供方法<br>体，具体实现由实现类完成。</p><p>&nbsp;&nbsp;&nbsp;<br> 接口中的属性：public static final，即只能是常量</p><p> &nbsp;&nbsp;&nbsp;<br> 接口中的方法：public abstract，即方法必须为抽象方法</p><p> &nbsp;&nbsp;&nbsp;<br> 接口没有构造方法，所以不能实例化</p><p> &nbsp;&nbsp;&nbsp;<br> 接口可以通过extends继承其他接口</p><p> &nbsp;&nbsp;&nbsp;<br> 接口的实现必须实现接口所有方法，否则该类应该抽象类</p><p> <strong>接口的作用</strong></p><p>&nbsp;&nbsp;&nbsp;<br>1.多继承，java对象只能有一个父类，通过接口可以实现多继承</p><p>&nbsp;&nbsp;&nbsp;<br> 2.有利于代码规范，定义接口，可以让不同的开发人员按照统一规范来完成项目的开发工作，防止<br>开发人员随意命名，导致命名不清晰，代码混乱等</p><p>&nbsp;&nbsp;&nbsp;<br> 3.降低项目的耦合度，提高可扩展性。一个类被多个地方调用，当其中一个地方发生业务改变时，<br>通过定义一个新的实现类来解决即可，而避免改变所有调用的地方。</p><h3 id="接口新特性-1-8"><a href="#接口新特性-1-8" class="headerlink" title="接口新特性(1.8)"></a>接口新特性(1.8)</h3><p><strong>接口的默认方法</strong></p><p>&nbsp;&nbsp;&nbsp;<br>接口中特殊的方法，被default修饰，可以包含方法体</p><pre><code>public interface IHello {    void sayHi();    default void sayBye() { }}</code></pre><p>&nbsp;&nbsp;&nbsp;<br>作用：扩展接口功能，不破坏现有代码，让接口扩展新的功能。默认方法跟接口中其他方法不同，<br>它是可选的。子类可以根据需求选择是否需要重写该方法。</p><p>&nbsp;&nbsp;&nbsp;<br>注意：若一个类实现了多个接口，那么多个接口中不应该包含相同的默认方法，编辑会报错，除非<br>重写该默认方法。</p><p><strong>接口中的静态方法</strong></p><p>&nbsp;&nbsp;&nbsp;<br>等同于类中的静态方法，调用时可不需要实现接口或实例化接口的实例，来完成方法的调用。</p><pre><code>public interface IHello {    static void sayHello() {}}</code></pre><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="接口式函数"><a href="#接口式函数" class="headerlink" title="接口式函数"></a>接口式函数</h3><p><strong>a.函数式接口</strong></p><p>&nbsp;&nbsp;&nbsp;<br>有且仅包含一个抽象方法的接口(可以包含一个或多个静态或默认方法)。</p><pre><code>1.8之前：    java.lang.Runnable    java.util.concurrent.Callable    java.util.Comparator    java.io.FileFilter1.8之后：    java.util.function、Predicate&lt;T&gt; 、Supplier&lt;T&gt;</code></pre><p><strong>b.使用场景</strong></p><p>&nbsp;&nbsp;&nbsp;<br> Lambda表达式，使用Lambda表达式可以简化匿名内部类的实现 </p><pre><code>@FunctionalInterface注解：    该注解来定义接口，编译器强制检查接口中是否有且仅有一个抽象方法，如果不是，则编译出错</code></pre><h3 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><pre><code>  Lambda 允许把函数作为一个方法的参数或返回值（函数作为参数传递进方法中），使用 Lambda表达式可以使代码变的更加简洁紧凑。语法：    (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }    简化版：（）-&gt; {} （）代表参数，{}代表方法体，-&gt;代表运算符注意：    1) 所有参数类型，均可以省略    2) 当参数只有一个，小括号可以省略    3) 无返回值情况，当方法体只有一条语句，可以省略大括号    4) 有返回值情况，当方法体只有一条语句，可以省略大括号和return</code></pre><p><strong>示例</strong></p><pre><code>1）无参无返回public interface IHello {    void sayHello();}IHello iHello = () -&gt; {System.out.println(&quot;&quot;);};</code></pre><pre><code>2）单参，无返回public interface IHello2 {    void sayBye(String a);}IHello2 iHello2 = (a) -&gt;{System.out.println(&quot;a:&quot; + a);};</code></pre><pre><code>3）多参，无返回public interface IHello3 {    void sayHi(int a,int b);}IHello3 iHello3 = (a,b)-&gt;{ System.out.println(a + b);};</code></pre><pre><code>4）无参数，有返回public interface IHello4 {    int sayHi();}IHello4 iHello4 = () -&gt; {return 1;};</code></pre><pre><code>5）单参数，有返回public interface IHello5 {    int sayHi(int a);}IHello5 iHello5 = (a) -&gt;{return a*10;};</code></pre><pre><code>6）多参数，有返回值public interface IHello6 {    int sayHi(int a,int b);}IHello6 iHello6 = (a,b) -&gt; {return a+ b;};</code></pre><h3 id="Lambda表达式的特殊使用"><a href="#Lambda表达式的特殊使用" class="headerlink" title="Lambda表达式的特殊使用"></a>Lambda表达式的特殊使用</h3><p><strong>a.方法引用</strong></p><p>&nbsp;&nbsp;&nbsp;<br>    Lambda表达式可以直接指向一个已经实现的方法</p><p>&nbsp;&nbsp;&nbsp;<br>要求：①：该方法的参数数量和参数类型必须跟接口中的方法一致 ②：该方法的返回值类型必须<br>与接口中的一致</p><pre><code>public interface IHello5 {    int sayHi(int a);}public static int change(int a) {    return a;}IHello5 iHello5 = a -&gt; change(a);</code></pre><p><strong>b.双冒号(::)的使用</strong></p><pre><code>普通方法：(参数是某个对象，调用该对象的方法)public interface IPerson {    int getPerson(Person person);}原装版：IPerson iPerson = (person) -&gt; {return person.getAge();};简化版：IPerson iPerson = Person::getAge;注意：参数对象调用的方法必需是无参</code></pre><pre><code>构造方法：(返回值是某个对象)public interface IPerson {    Person getPerson();}原装版：IPerson iPerson = () -&gt; {return new Person();};简化版：IPerson iPerson = Person::new;注意:调用的为无参构造</code></pre><h3 id="系统内置函数式接口"><a href="#系统内置函数式接口" class="headerlink" title="系统内置函数式接口"></a>系统内置函数式接口</h3><pre><code>Consume：参数为T，无返回public interface Consumer&lt;T&gt; {    void accept(T t);}Supplier：无参有返回public interface Supplier&lt;T&gt; {    T get();}Predicate：泛型参数T，返回值booleanpublic interface Predicate&lt;T&gt; {    boolean test(T t);}Function：参数为T，返回值为Rpublic interface Function&lt;T, R&gt; {    R apply(T t);}</code></pre><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Stream：中文成为”流”，一种对集合或者数组进行处理的工具，又被称为”操作符”；操作符分类两<br>类：中间操作符、终止操作符。一般来讲，流不会修改原来的数据，它会将操作后的数据保存到另一个<br>对象中。</p><pre><code>Stream使用步骤：    1）创建Stream对象     2）使用中间操作符进行操作     3）使用终止操作符</code></pre><h3 id="创建Strean对象"><a href="#创建Strean对象" class="headerlink" title="创建Strean对象"></a>创建Strean对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>stream对象的获取，可以分为数组、list、set、map（可以得到key的set集合、value的list集合）</p><p><strong>数组</strong></p><pre><code>String[] strArray = new String[] {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;,&quot;grape&quot;};Stream.of(strArray)//第一种Arrays.stream(strArray)//第二种</code></pre><p><strong>list、set</strong></p><pre><code>    List&lt;Student&gt; stuList = new ArrayList&lt;Student&gt;();    stuList.stream();//串行    stuList.parallelStream();//并行    Set&lt;Student&gt; set = new HashSet&lt;&gt;();    set.stream();    set.parallelStream();</code></pre><h3 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>对数据执行操作后，数据依然可以传递给下一级操作符。（一般都需要传递给终止操作符，因为中<br>间操作符返回值为Stream对象，不传递给终止操作符返回处理后的数据没有意义）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>中间操作符主要分为8种：</p><pre><code>转换操作符：把原始数据转换为你所需要的数据，默认可转换成int、long、double类型map,mapToInt,mapToLong,mapToDouble拍平操作符：即拆开，把数组拆分成单个字段，默认提供了拍平成int,long,double的操作符。flatmap,flatmapToInt,flatmapToLong,flatmapToDouble限流操作符：比如数据流中有10条数据，只取其中三条limit去重操作符：去掉重复数据distinct过滤操作符：筛掉不想要的数据filter跳过操作符：跳过某些元素skip挑出操作符：对数据进行某些操作，如读取、编辑修改等peek排序操作符：sorted</code></pre><p><strong>map转换操作符</strong></p><pre><code>String[] strArray = new String[] {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;,&quot;grape&quot;};Stream.of(strArray)    .map(e -&gt; e.length())    .forEach(e -&gt; System.out.println(e));</code></pre><p><strong>flatMap拍平操作符</strong></p><pre><code>Stream.of(&quot;a-b-c-d&quot;,&quot;e-f-i-g-h&quot;)    .flatMap(e-&gt;Stream.of(e.split(&quot;-&quot;)))    .forEach(e-&gt;System.out.println(e));</code></pre><p><strong>limit限流操作符</strong></p><pre><code>Stream.of(1,2,3,4,5,6)    .limit(3) //限制三个    .forEach(e-&gt;System.out.println(e));</code></pre><p><strong>distinct去重操作符</strong></p><pre><code>Stream.of(1,2,3,1,2,5,6,7,8,0,0,1,2,3,1)    .distinct() //去重    .forEach(e-&gt;System.out.println(e));</code></pre><p><strong>filter过滤操作符</strong></p><pre><code>Stream.of(1,2,3,1,2,5,6,7,8,0,0,1,2,3,1)    .filter(e-&gt;e&gt;=5) //过滤小于5的    .forEach(e-&gt;System.out.println(e));</code></pre><p><strong>skip跳过操作符</strong></p><pre><code>Stream.of(1,2,3,4,5,6,7,8,9)    .skip(4) //跳过前四个    .forEach(e-&gt;System.out.println(e));</code></pre><p><strong>peek挑出操作符</strong></p><pre><code>User w = new User(&quot;w&quot;,10);User x = new User(&quot;x&quot;,11);User y = new User(&quot;y&quot;,12);Stream.of(w,x,y)    .peek(e-&gt;{e.setName(e.getAge()+e.getName());}) //重新设置名字 变成 年龄+名字    .forEach(e-&gt;System.out.println(e.toString()));</code></pre><p><strong>sorted排序操作符</strong></p><pre><code>Stream.of(2,1,3,6,4,9,6,8,0)    .sorted() //默认排序    .forEach(e-&gt;System.out.println(e));User x = new User(&quot;x&quot;,11);User y = new User(&quot;y&quot;,12);User w = new User(&quot;w&quot;,10);Stream.of(w,x,y)    .sorted((e1,e2)-&gt;e1.age&gt;e2.age?1:e1.age==e2.age?0:-1)    .forEach(e-&gt;System.out.println(e.toString()));注意：多重三元运算符（三目运算符）嵌套String str = a.equals(&quot;123&quot;) ? &quot;123&quot; : ( b.equals(&quot;456&quot;) ? &quot;456&quot; : &quot;789&quot;);//如果a等于123，就给str赋值123;否则,如果b等于456,就给str赋值123,前面两个如果都不成立就赋值789</code></pre><h3 id="终止操作符"><a href="#终止操作符" class="headerlink" title="终止操作符"></a>终止操作符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>中间操作符处理数据后，须有终止操作符进行收集、消费操作。终止操作符只能用一次。</p><pre><code>收集操作符：将数据收集起来    collect统计操作符：    count查找操作符：    findFirst，findAny匹配操作符：流中是否存在符合条件的元素，返回boolean值    noneMatch、allMatch、anyMatch最值操作符：    max,min遍历操作符：    forEach数组操作符：将数据流元素变为数组    toArray规约操作符：将整个数据流规约为一个值，count/min/max都属于规约    reduce</code></pre><p><strong>collect收集操作符</strong></p><pre><code>Set&lt;String&gt; stringSet =    Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;, &quot;grape&quot;)    .collect(Collectors.toSet()) //set 容器</code></pre><p><strong>count统计操作符</strong></p><pre><code>long count =Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;, &quot;grape&quot;).count();</code></pre><p><strong>查找操作符</strong></p><pre><code>findFirst:取流中的第一个元素    Optional&lt;String&gt; stringOptional =        Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;, &quot;grape&quot;)        .findFirst();    stringOptional.get();//得到第一个元素findAny：获取流中任意一个元素    Optional&lt;String&gt; findFirst =        Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;, &quot;grape&quot;)        .findAny();    stringOptional.get();//得到任意一个元素，实际还是第一个</code></pre><p><strong>匹配操作符</strong></p><pre><code>boolean result = Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;aa&quot;)                .noneMatch(e-&gt;e.equals(&quot;aa&quot;));noneMatch：没有一个匹配返回trueallMatch:全部匹配返回trueanyMatch：任意一个匹配返回true</code></pre><p><strong>最值操作符：</strong></p><pre><code>Optional&lt;Integer&gt; integerOptional =    Stream.of(0,9,8,4,5,6,-1)    .max((e1,e2)-&gt;e1.compareTo(e2));//max元素中最大的    .min((e1,e2)-&gt;e1.compareTo(e2));//min元素中最大的</code></pre><p><strong>reduce规约操作符</strong></p><pre><code>所有的元素归约成一个，比如对所有元素求和，乘等int sum = Stream.of(0,9,8,4,5,6,-1)    .reduce(0,(e1,e2)-&gt;e1+e2);</code></pre><p><strong>toArray 数组操作符</strong></p><pre><code>转成数组Object[] objects=Stream.of(0,2,6,5,4,9,8,-1)        .toArray();</code></pre><h2 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h2><h3 id="新旧版本的区别"><a href="#新旧版本的区别" class="headerlink" title="新旧版本的区别"></a>新旧版本的区别</h3><pre><code>旧版本：    1）线程不安全    2）设计较差，java.util、java.sql都有日期类，而格式化类却在java.text包下，设计不合理    3）时区处理麻烦：日期类不提供国际化，没有时区支持新版本：(java.time包)    1）Local(本地)：简化了日期时间的处理，没有时区问题    2）Zoned(时区)：通过制定时区处理日期时间问题</code></pre><h3 id="本地化日期时间API"><a href="#本地化日期时间API" class="headerlink" title="本地化日期时间API"></a>本地化日期时间API</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>主要涉及的类为：LocalDate、LocalTime、LocalDateTime</p><table>    <tr>        <th rowspan>方法</th>        <th>描述</th>    </tr>    <tr>        <td>now()</td>        <td>静态方法，根据当前时间创建对象</td>    </tr>    <tr>        <td>plusDays, plusWeeks, plusMonths,plusYears</td>        <td>向当前 LocalDate 对象添加几天、 几周、几个月、几年</td>    </tr>    <tr>        <td>minusDays, minusWeeks,minusMonths, minusYears</td>        <td>从当前 LocalDate 对象减去几天、 几周、几个月、几年</td>    </tr>    <tr>        <td>plus, minus</td>        <td>添加或减少一个 Duration或 Period</td>    </tr>    <tr>        <td>withDayOfMonth, withDayOfYear,withMonth, withYear</td>        <td>将月份天数、年份天数、月份、年 份修改为指定的值并返回新的 LocalDate对象</td>    </tr>    <tr>        <td>getDayOfMonth</td>        <td>获得月份天数(1-31)</td>    </tr>    <tr>        <td>getDayOfYear</td>        <td>获得年份天数(1-366)</td>    </tr>    <tr>        <td>getDayOfWeek</td>        <td>获得星期几(返回一个 DayOfWeek 枚举值)</td>    </tr>    <tr>        <td>getMonth</td>        <td>获得月份, 返回一个 Month枚举值</td>    </tr>    <tr>        <td>getMonthValue</td>        <td>获得月份(1-12)</td>    </tr>    <tr>        <td>getYear</td>        <td>获得年份</td>    </tr>    <tr>        <td>until</td>        <td>获得两个日期之间的 Period 对象， 或者指定ChronoUnits的数字</td>    </tr>    <tr>        <td>isBefore, isAfter</td>        <td>比较两个 LocalDate</td>    </tr>    <tr>        <td>isLeapYear</td>        <td>判断是否是闰年</td>    </tr></table><pre><code>******对象创建******LocalDate localDate = LocalDate.now();//获取当前日期LocalDate localDate = LocalDate.of(year, month, dayOfMonth);//获取特定日期******获取年、月、日信息******int year = localDate.getYear();//年int monthValue = localDate.getMonthValue();//月int dayOfMonth = localDate.getDayOfMonth();//日int dayOfYear = localDate.getDayOfYear();//一年中的第几天int dayOfWeek = localDate.getDayOfWeek();//周几******枚举对象ChronoField获取年、月、日信息******int year = localDate.get(ChronoField.YEAR);int month = localDate.get(ChronoField.MONTH_OF_YEAR);int day = localDate.get(ChronoField.DAY_OF_MONTH);******日期修改******LocalDate date = localDate.withYear(year);//变为指定年LocalDate date = localDate.withMonth(month);//变为指定月LocalDate date = localDate.withDayOfMonth(dayOfMonth);//变为指定日//日期添加LocalDate date = localDate.plus(amountToAdd, unit);LocalDate date = localDate.plusYears(yearsToAdd);LocalDate date = localDate.plusMonths(monthsToAdd);LocalDate date = localDate.plusWeeks(weeksToAdd);LocalDate date = localDate.plusDays(daysToAdd)//日期减少LocalDate date = localDate.minnus(amountToAdd, unit);LocalDate date = localDate.minnusYears(yearsToAdd);LocalDate date = localDate.minnusMonths(monthsToAdd);LocalDate date = localDate.minnusWeeks(weeksToAdd);LocalDate date = localDate.minnusDays(daysToAdd)******日期比较******localDate.isAfter(otherDate)localDate.isBefore(otherDate)******其他方法******int len = localDate.lengthOfMonth();//31(这个月有多少天)boolean leap = localDate.isLeapYear();//false(是不是闰年)localDate.toEpochDay() - specialDay.toEpochDay();//日期间隔天数</code></pre><h4 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h4><pre><code>//解析日期String dateStr= &quot;2018年12月18日&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);LocalDate date= LocalDate.parse(dateStr, formatter);//日期转换为字符串LocalDateTime now = LocalDateTime.now();DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);String nowStr = now .format(format);System.out.println(nowStr);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2020/07/09/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/07/09/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h2><pre><code>想要了解反射机制，需要先了解两个概念：编译期和运行期。编译期：把源代码翻译成机器能识别的代码，比如编译器把java代码编译成jvm识别的字节码文件运行期：将可执行文件交给操作系统去执行反射机制：在运行期，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</code></pre><p><strong>（简述：java中，只要给定类的名字，就可以在运行时通过反射机制来获得类的所有信息）</strong></p><h2 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h2><ul><li>运行时判断对象所属的类</li><li>运行时构造一个类的对象</li><li>运行时，判断一个类所具有的的成员变量和方法</li><li>运行时调用任意一个对象的方法</li></ul><p><strong>使用场景</strong></p><p>1.反编译(.class变成.java)</p><p>2.开发框架,反射是框架设计的灵魂。比如Spring，为了保证框架的通用性，框架需要根据配置文件<br>加载不同的类或对象（运行期间，动态加载所需对象）。</p><p><strong>优缺点</strong></p><p>对象的创建，分为静态和动态两种。<strong>静态</strong>：编译时即确定具体类型，绑定对象。动态：运行时才会<br>确定具体类型，能够有效降低类之间的耦合度，最大限度发挥了java的灵活性。</p><p><strong>反射机制优点</strong>：实现对象的动态创建和编译，体现了很大的灵活性。比如：一个大型软件，不可能<br>一次就设计的很完美，当需要增加新功能时，如何解决？卸载以后重新安装新版本？这是不合适的。静<br>态编译则必须这样做，而反射机制的动态特性可以帮助我们解决这个问题，无需卸载，只需要运行时动<br>态的加载，即可创建和编译新对象。</p><p><strong>缺点</strong>：对系统性能会产生影响。</p><h2 id="反射机制的实现"><a href="#反射机制的实现" class="headerlink" title="反射机制的实现"></a>反射机制的实现</h2><blockquote><p>java中，使用一个类需要把该类加载到虚拟机中，并生成一个Class对象，这个对象保存了该类<br>的所有信息。反射机制的实现，就是获取这个Class对象。</p></blockquote><p><strong>class对象的获取</strong></p><p>  第一种：（已存在对象，无需反射）</p><pre><code>Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。Class stuClass = stu1.getClass();//获取Class对象System.out.println(stuClass.getName())</code></pre><p>  第二种：（需要导入类包，依赖太强）</p><pre><code>Class stuClass2 = Student.class;//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个System.out.println(stuClass == stuClass2);</code></pre><p>  第三种：（常用，传入一个字符串即可，或者写在配置文件中）</p><pre><code>//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名Class stuClass3 = Class.forName(&quot;cn.bdqn.Student&quot;);//判断三种方式是否获取的是同一个Class对象System.out.println(stuClass3 == stuClass2);</code></pre><p>  反射机制常用的类</p><pre><code>Java.lang.Class; //类Java.lang.reflect.Constructor; //构造方法Java.lang.reflect.Field; //属性Java.lang.reflect.Method; //方法</code></pre><h2 id="反射机制的使用"><a href="#反射机制的使用" class="headerlink" title="反射机制的使用"></a>反射机制的使用</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote><p>使用反射机制创建对象有两种方式：newInstance()方法和Constructor对象</p></blockquote><p>1.使用Class对象的newInstance()方法创建对象</p><pre><code>Class&lt;?&gt; c = Class.forName(&quot;cn.bdqn.Student&quot;);Object str = c.newInstance();</code></pre><p>2.调用Constructor对象</p><pre><code>/获取String的Class对象Class&lt;?&gt; c = Class.forName(&quot;cn.bdqn.Student&quot;);//通过Class对象获取指定的Constructor构造器对象Constructor constructor=c.getConstructor(String.class);//根据构造器创建实例：Object obj = constructor.newInstance(“hello reflection”);   </code></pre><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><p><strong>获取构造方法</strong></p><pre><code>//所有&quot;公有的&quot;构造方法public Constructor[] getConstructors()//获取所有的构造方法(包括私有、受保护、默认、公有）public Constructor[] getDeclaredConstructors()//获取单个的&quot;公有的&quot;构造方法public Constructor getConstructor(Class... parameterTypes)//获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有public Constructor getDeclaredConstructor(Class... parameterTypes)</code></pre><p><strong>调用构造方法</strong></p><pre><code>//对象获取构造的方法getConstructornewInstance(Object... initargs)</code></pre><p>示例:</p><pre><code>//1.加载Class对象Class clazz = Class.forName(&quot;cn.bdqn.Student&quot;);//2. 获取构造方法******获取所有公有构造方法******System.out.println(&quot;***所有公有构造方***&quot;);Constructor[] conArray = clazz.getConstructors();for(Constructor c : conArray){System.out.println(c);}******获取所有构造方法******System.out.println(&quot;***所有的构造方法(包括：私有、受保护、默认、公有)***&quot;);conArray = clazz.getDeclaredConstructors();for(Constructor c : conArray){System.out.println(c);}****** 获取公有、无参的构造方法******System.out.println(&quot;***获取公有、无参的构造方法***&quot;);Constructor constructor = clazz.getConstructor(null);//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型//2&gt;、返回的是描述这个无参构造函数的类对象。System.out.println(&quot;con = &quot; + con);//3.对象创建******调用无参构造创建对象******Object newInstance = constructor.newInstance();******调用有参构造创建对象******Constructor constructor = clazz.getConstructor(String.class);//参数用以指定类型constructor.newInstance(new Object[]{&quot;xm&quot;});//参数用以赋值</code></pre><h3 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h3><p><strong>获取成员变量</strong></p><pre><code>//批量获取******获取所有的&quot;公有字段******Field[] getFields()******获取所有字段，包括：私有、受保护、默认、公有******Field[] getDeclaredFields()//单个获取******获取某个&quot;公有的&quot;字段******public Field getField(String fieldName)******获取某个字段(可以是私有的)******public Field getDeclaredField(String fieldName)</code></pre><p>示例:</p><pre><code>Class clazz = Class.forName(&quot;cn.bdqn.Student&quot;);Object obj = clazz.getConstructor().newInstance();System.out.println(&quot;************获取所有公有的字段********************&quot;);Field[] fieldArray = clazz.getFields();System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);fieldArray = clazz.getDeclaredFields();System.out.println(&quot;******获取公有字段并调用******&quot;);Field f = clazz.getField(&quot;name&quot;);//为字段设置值,为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;f.set(obj, &quot;刘德华&quot;);//验证Student stu = (Student)obj;System.out.println(&quot;验证姓名：&quot; + stu.name);System.out.println(&quot;******获取私有字段并调用******&quot;);f = clazz.getDeclaredField(&quot;phoneNum&quot;);System.out.println(f);f.setAccessible(true);//暴力反射，解除私有限定f.set(obj, &quot;18888889999&quot;);System.out.println(&quot;验证电话：&quot; + stu);</code></pre><h3 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h3><p><strong>获取成员方法</strong></p><pre><code>//批量的public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)//获取单个public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)参数说明：* name : 方法名；* Class ... : 形参的Class类型对象</code></pre><p>调用方法</p><pre><code>public Object invoke(Object obj,Object... args):参数说明：* obj : 要调用方法的对象；* args:调用方式时所传递的实参；</code></pre><p>示例</p><pre><code>Class clazz = Class.forName(&quot;cn.bdqn.Student&quot;);Object obj = clazz.getConstructor().newInstance();//2.获取所有公有方法System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);Method[] methodArray = clazz.getMethods();System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);Method[] methodArray = clazz.getDeclaredMethods();System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);Method m = stuClass.getMethod(&quot;show1&quot;, String.class);//实例化一个Student对象Object obj = stuClass.getConstructor().newInstance();m.invoke(obj, &quot;刘德华&quot;);System.out.println(&quot;***************获取私有的show4()方法******************&quot;);m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);m.setAccessible(true);//解除私有限定Object result = m.invoke(obj, 20);System.out.println(&quot;返回值：&quot; + result);</code></pre><h3 id="通过反射机制运行配置内容"><a href="#通过反射机制运行配置内容" class="headerlink" title="通过反射机制运行配置内容"></a>通过反射机制运行配置内容</h3><p>配置文件pro.txt</p><pre><code>className=cn.bdqn.StudentmethodName=show</code></pre><p>测试类</p><pre><code>public class Demo {public static void main(String[] args) throws Exception {//通过反射获取Class对象    Class stuClass = Class.forName(getValue(&quot;className&quot;));//cn.bdqn.Student    //2获取show()方法    Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));//show    //3.调用show()方法    m.invoke(stuClass.getConstructor().newInstance());}//此方法接收一个key，在配置文件中获取相应的valuepublic static String getValue(String key) throws IOException{    Properties pro = new Properties();//获取配置文件的对象    FileReader in = new FileReader(&quot;pro.txt&quot;);//获取输入流    pro.load(in);//将流加载到配置文件对象中    in.close();    return pro.getProperty(key);//返回根据key获取的value值    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Docker</title>
      <link href="/2020/07/02/Linux%E5%AE%89%E8%A3%85Docker/"/>
      <url>/2020/07/02/Linux%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux配置Docker"><a href="#Linux配置Docker" class="headerlink" title="Linux配置Docker"></a>Linux配置Docker</h1><p>1.切换到root用户,更新软件安装源,安装完成重启虚拟机</p><pre><code>yum update</code></pre><p>2.查看自带的JAVA,删除自带的JDK</p><pre><code>rpm -qa|grep java yum remove</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1.关闭,禁用防火墙</p><pre><code>systemctl stop firewalldsystemctl disable firewalld</code></pre><p>2.移除自带的docker</p><pre><code>yum -y remove docker-common container-selinux</code></pre><p>3.更新yum源</p><pre><code>yum install -y yum-utils</code></pre><p>4.配置docker安装源的路径</p><pre><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>5.设置缓冲区</p><pre><code>yum makecache fast</code></pre><p>6.安装</p><pre><code>yum -y install docker-ce</code></pre><p>7.安装完成查看版本</p><pre><code>docker version</code></pre><p>  出现</p><p>  <img src="/2020/07/02/Linux%E5%AE%89%E8%A3%85Docker/wenti.jpg" alt="wenti"></p><p>  执行</p><pre><code>systemctl daemon-reloadsystemctl restart docker.service</code></pre><h4 id="创建Docker可视化容器"><a href="#创建Docker可视化容器" class="headerlink" title="创建Docker可视化容器"></a>创建Docker可视化容器</h4><p>1.拉取镜像</p><pre><code>docker pull portainer/portainer</code></pre><p>2.创建挂载卷</p><pre><code>docker volume create portainer_data</code></pre><p>3.创建容器</p><pre><code>docker run -it -d -p 9010:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data --restart=always --name portainer portainer/portainer</code></pre><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><blockquote><p>在/home/ /创建一个文件夹放dockerFile文件</p></blockquote><p>1.拉取底层镜像centos:7.2.1511</p><pre><code>docker pull centos:7.2.1511</code></pre><p>2.dockerFile安装centos-ssh镜像<br>    centos-ssh文件上传到服务器安装</p><pre><code>docker bulid -t centos-ssh /home/ /dockerenv/centos7-ssh/</code></pre><p>3.创建jdk</p><pre><code>docker build -t jdk8 /home/ /dockerenv/jdk8u171/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2020/06/27/SpringBoot/"/>
      <url>/2020/06/27/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h2><h4 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h4><p>谈到SpringBoot，首先谈一下Spring。Spring框架为Java应用程序开发提供全面基础架构支持的框架，<br>它简化了大量的重复代码的操作，比如数据库连接，让我们的开发时间大大缩短。它的主要模块如下 :</p><pre><code>    Spring JDBC：简化JDBC编码，使代码更加健壮    Spring MVC：提供对Web程序的支持    Spring Security：提供对安全访问控制的支持 shiro    Spring AOP：基础IOC/DI，提供面向切面编程的实现    Spring ORM：提供对当前市面上流行的ORM框架的支持    Spring Test：提供对单元测试、集成测试等的支持</code></pre><p>随着动态语言的流行（Ruby、Node.js），java开发显得格外笨重，繁多的配置、低下的开发效率、复<br>杂的部署流程以及第三方技术集成的难度大。<br>在上述情况下，SpringBoot应运而生，它使用“习惯优于配置”，使我们不用或很少的配置。</p><hr><h2 id="SpringBoot核心功能"><a href="#SpringBoot核心功能" class="headerlink" title="SpringBoot核心功能"></a>SpringBoot核心功能</h2><p>1.内嵌的Servlet容器</p><p> &nbsp;&nbsp;&nbsp;&nbsp;SpringBoot可以内嵌Tomcat、Jetty等，这样我们无需以war形式部署项目</p><p>2.提供starer简化Maven配置</p><p>&nbsp;&nbsp;&nbsp;&nbsp; Spring提供了一系列的starer pom 来简化Maven的依赖加载，常用starer依赖：</p><pre><code>    spring-boot-starter-data-jpa    spring-boot-starter-security    spring-boot-starter-test    spring-boot-starter-web    spring-boot-starter-thymeleaf</code></pre><hr><h2 id="SpringBoot项目快速搭建"><a href="#SpringBoot项目快速搭建" class="headerlink" title="SpringBoot项目快速搭建"></a>SpringBoot项目快速搭建</h2><p>1.网站搭建</p><p>&nbsp;&nbsp;<a href="https://start.spring.io/" target="_blank" rel="noopener">浏览器访问</a>，填写Group、artifact、dependencies，点击创建按钮。</p><p><img src="/2020/06/27/SpringBoot/springboot.png" alt="springboot"></p><p>2.使用Spring Tool Suite(STS)<br>即eclipse工具安装SpringBoot插件，创建项目</p><p>3.使用Intellij IDEA工具创建项目<br>第二和第三种创建方式，本质还是访问<a href="https://start.spring.io/创建项目，所以需要有网络" target="_blank" rel="noopener">https://start.spring.io/创建项目，所以需要有网络</a></p><hr><h2 id="SpringBoot基本配置"><a href="#SpringBoot基本配置" class="headerlink" title="SpringBoot基本配置"></a>SpringBoot基本配置</h2><h4 id="SpringBoot的配置文件"><a href="#SpringBoot的配置文件" class="headerlink" title="SpringBoot的配置文件"></a>SpringBoot的配置文件</h4><blockquote><p>全局配置文件：application.properties或application.yml</p></blockquote><pre><code>    常用简单配置：        server.port= 8080        server.context-path= /helloboot        自定义属性配置：        属性定义            book.author= xm            book.name= SpringBoot        属性使用            @Value(“${book.author}”)            String bookAuthor;            @Value(“${book.name}”)            String bookName;</code></pre><h2 id="SpringBoot的常用注解"><a href="#SpringBoot的常用注解" class="headerlink" title="SpringBoot的常用注解"></a>SpringBoot的常用注解</h2><pre><code>类注解    @RestController，等同于@Controller + @responseBodyurl注解    @RequestMapping参数注解    @GetMapping组合注解（get请求方式的RequestMapping）    @PostMapping组合注解（post请求方式的RequestMapping）    @PathVariable 获取url中的数据    @RequestParam 获取参数中的数据</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK+Kafka</title>
      <link href="/2020/06/25/ELK-Kafka/"/>
      <url>/2020/06/25/ELK-Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="ELK-Kafka"><a href="#ELK-Kafka" class="headerlink" title="ELK+Kafka"></a>ELK+Kafka</h1><h3 id="利用ELK-Kafka解决方案，搭建企业级实时日志分析平台"><a href="#利用ELK-Kafka解决方案，搭建企业级实时日志分析平台" class="headerlink" title="利用ELK+Kafka解决方案，搭建企业级实时日志分析平台"></a>利用ELK+Kafka解决方案，搭建企业级实时日志分析平台</h3><blockquote><p>ELK 是三款软件的组合。是一整套完整的解决方案。分别是由 Logstash（收集+分析）、ElasticSearch（搜索+存储）、Kibana（可视化展示）三款软件。ELK主要是为了在海量的日志系统里面实现分布式日志数据集中式管理和查询，便于监控以及排查故障。</p></blockquote><hr><h4 id="准备DockerFile文件"><a href="#准备DockerFile文件" class="headerlink" title="准备DockerFile文件"></a>准备DockerFile文件</h4><p>1.修改ElasticSearch的DockerFile依赖的JDK镜像名</p><pre><code>    FROM jdk镜像名</code></pre><p>2.修改Kafka的DockerFile依赖的JDK镜像名,倒数第二行添加</p><pre><code>    FROM jdk镜像名</code></pre><pre><code>    EXPOSE 9092</code></pre><p>3.修改Kafka的Service.properties文件,改为你的虚拟机地址</p><pre><code>    advertised.listeners=PLAINTEXT://192.168.71.132:9092    zookeeper.connect=192.168.71.132:2181   </code></pre><p>4.修改Kibana的DockerFile依赖的JDK镜像名</p><pre><code>    FROM jdk镜像名</code></pre><p>5.修改Kibana.yml文件,改为你的虚拟机地址</p><pre><code>    elasticsearch.url: &quot;http://192.168.71.132:9200&quot;</code></pre><p>6.修改Kibana的DockerFile依赖的JDK镜像名</p><pre><code>    FROM jdk镜像名</code></pre><p>7.把logstash.conf文件中所有的IP地址改为你的</p><p>8.logstash.yml文件,IP地址</p><pre><code>    xpack.monitoring.elasticsearch.url: http://192.168.71.132:9200</code></pre><p>9.把ELK+Kafka文件夹拉入服务器</p><p>10.安装ElasticSearch镜像,创建容器</p><pre><code>    //执行DockerFile    docker build -t elasticsearch /home/kds/dockermv/Elasticsearch/    //创建容器    docker run -it -d -p 9200:9200 --name elasticsearch elasticsearch</code></pre><p>11.创建Kibana镜像,创建容器</p><pre><code>    //创建镜像    docker build -t kibana /home/kds/dockermv/Kibana/    //创建容器    docker run -it -d -p 5601:5601 --name kibana kibana</code></pre><p>12.创建Kafka镜像,创建容器</p><pre><code>    //创建镜像    docker build -t kafka /home/kds/dockermv/Kafka/    //创建容器    docker run -it -d -p 9092:9092 --name kafka kafka</code></pre><p>13.创建logstash</p><pre><code>    //创建镜像    docker build -t logstash /home/kds/dockermv/Logstash/    //创建容器    docker run -it -d logstash logstash</code></pre><hr><h3 id="ElasticSearch启动不成功"><a href="#ElasticSearch启动不成功" class="headerlink" title="ElasticSearch启动不成功"></a>ElasticSearch启动不成功</h3><ul><li><p>先限制性</p><pre><code>  sysctl -w vm.max_map_count=262144</code></pre></li><li><p>重启docker服务</p><pre><code>  systemctl  restart docker</code></pre></li><li><p>启动ElasticSearch容器</p></li></ul><h4 id="启动容器的步骤"><a href="#启动容器的步骤" class="headerlink" title="启动容器的步骤"></a>启动容器的步骤</h4><ul><li>先启动ElasticSearch</li><li></li><li>再启动Kibana</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActivedMQ的简单应用</title>
      <link href="/2020/06/24/ActivedMQ%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2020/06/24/ActivedMQ%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h1><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>消息队列是在消息的传播过程中保存消息的容器<br><br><br><br>　<br>消息队列中间件是分布式系统中的重要组件,主要解决异步消息,应用解耦,流量削峰等问题,从而实现高性能,高可用,可伸缩和最终一致性的架构</p></blockquote><ul><li>异步请求</li><li>应用解耦</li><li>流量削峰</li></ul><hr><blockquote><p>Docker环境搭建</p></blockquote><p>通过Docker文件进行创建生成镜像文件<br></p><pre><code>docker build -t activemq/home/kds/dockermv/activeMQ5.15.2/</code></pre><p>创建容器<br></p><pre><code>docker run -it -d -p 8161:8161 -p 61616:61616 --name activemq activemq8161:HTTP协议61616:TCP协议</code></pre><hr><h3 id="ActiveMQ的简单应用"><a href="#ActiveMQ的简单应用" class="headerlink" title="ActiveMQ的简单应用"></a>ActiveMQ的简单应用</h3><a id="more"></a><p>1.创建发送者produce</p><p>2.导入SpringBoot整合ActiveMQ依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>3.向yml文件中添加属性</p><pre><code>    spring:        activemq:            broker-url: tcp://192.168.71.131:61616            in-memory: true            pool:                enabled: false            packages:                trust-all: true</code></pre><p>4.创建controller</p><pre><code>@Resourceprivate JmsMessagingTemplate jmsMessagingTemplatel;@RequestMapping(&quot;/send&quot;)public String send(String message){    //创建队列的名称    Queue queue = new ActiveMQQueue(&quot;消息队列1&quot;);    //将消息发送到服务器中    jmsMessagingTemplatel.convertAndSend(queue,message);    return &quot;发送成功&quot;;}</code></pre><p>5.启动类添加注解,运行访问</p><pre><code>@EnableJms</code></pre><p>6.创建消费者Consumer,修改yml文件</p><pre><code>spring:    activemq:        broker-url: tcp://192.168.71.131:61616        in-memory: true        pool:            enabled: false        packages:            trust-all: trueserver:    port: 6666</code></pre><p>7.添加测试类</p><pre><code>@Componentpublic class Test {    @JmsListener(destination = &quot;消息队列2&quot;)    public void getMessage(String message){        System.out.println(message);    }}</code></pre><p>8.启动类添加注解,启动</p><pre><code>@EnableJms</code></pre><hr><h3 id="ActiveMQ参数信息"><a href="#ActiveMQ参数信息" class="headerlink" title="ActiveMQ参数信息"></a>ActiveMQ参数信息</h3><ul><li>Number Of Pending Messages     等待处理的消息有多少条</li><li>Number Of Consumers    有多少个消费者去处理消息</li><li>Messages Enqueued    进入队列的中的消息有多少条</li><li>Messages Dequeued    已处理的消息有多少条</li></ul><hr><h4 id="JMS消息模型P2P-Point-to-Point-点对点模式"><a href="#JMS消息模型P2P-Point-to-Point-点对点模式" class="headerlink" title="JMS消息模型P2P(Point to Point)点对点模式"></a>JMS消息模型P2P(Point to Point)点对点模式</h4><p>P2P模式包含三个角色:<br><br>   &nbsp; &nbsp;&nbsp;  消息队列(Queue),发送者(Sender),接收者(Receiver)</p><pre><code>Queue queue = new ActiveMQQueue(&quot;消息队列1&quot;);</code></pre><ul><li>每个消息只有一个消费者(Consumer)</li><li>发送者和接收者之间在时间上没有依赖性,也就是说当发送者发送了消息之后,不管接收者有没有正在运行,它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需要想队列应答成功</li></ul><hr><h4 id="Publish-Subscribe-Pub-Sub-发布订阅模式"><a href="#Publish-Subscribe-Pub-Sub-发布订阅模式" class="headerlink" title="Publish/Subscribe(Pub/Sub)发布订阅模式"></a>Publish/Subscribe(Pub/Sub)发布订阅模式</h4><p>Pbu/Sub模式包含三个角色:<br><br>    &nbsp; &nbsp;&nbsp;<br>    主题(Topic),发布者(Publisher),订阅者(Receiver)</p><pre><code>Topic topic = new ActiveMQTopic(&quot;订阅队列&quot;);//配置消息中间件的模式  false 点对点模式   true 发布订阅模式//发布者消费者需要配置jms:     pub-sub-domain: true</code></pre><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性.针对某个主题的订阅者,他必须创建一个订阅之后,才能消费发布者的消息</li><li>为了消费消息,订阅者必须保持运行的状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
